#include "satelliteComs.h"
#include <stdint.h>
#include <Arduino.h>
#include "thrusterSubsystem.h"
#include "solarPanel.h"
#include "schedule.h"
#include "sharedVariables.h"


#define MAX_COMMAND_HANDLERS 10
#define COMMAND_SYNC_PATTERN 0xEE474DAB
#define SERIAL_TIMEOUT_MS    100


typedef struct {
    uint8_t entityId;
    cmd_handler_fn handle;
} CommandHandler;


void printBool(bool input);

void printSolarPanelState(SolarPanelState state);

void sendTelemetryPacket(void *data, size_t size, uint8_t tlmId);

void processCommand();

// returns true if it found the sync bytes
// times out after 100 ms
bool sync();


TCB satelliteComsTCB;

SatelliteComsData satelliteComsData = {
    &fuelLow,
    &batteryLow,
    &solarPanelState,
    batteryLevelPtr,
    &fuelLevel,
    &powerConsumption,
    &powerGeneration,
    &thrusterCommand,
    &vehicleResponse
};

const char* const taskName = "Satellite Communications";

CommandHandler commandHandlers[MAX_COMMAND_HANDLERS];
uint8_t numCommandHandlers = 0;
uint8_t syncBytes[4];

void satelliteComsInit() {
    tcbInit(
        &satelliteComsTCB,
        &satelliteComsData,
        satelliteComs,
        taskName,
        1
    );

    Serial.setTimeout(SERIAL_TIMEOUT_MS);
}

/******************************************************************************
 * name : satelliteComs
 *
 * inputs: satelliteComsData (void*)
 * satelliteComsData holds the pointers to the following data:
 * fuelLow: bool representing if the fuel is too low
 * batteryLow: bool representing if the battery is too low
 * solarPanelState: bool representing if the solar panel is deploued
 * batteryLevel: unsigned short representing the battery percentage
 * fuelLevel: unsigned short representing the fuel percentage
 * powerConsumption: unsigned short representing the power consumed by the system.
 * powerGeneration : unsigned short representing the power generated by the system.
 * thrusterCommand: unsigned int 32 bit thruster command
 *
 * outputs: void
 *
 * description:
 *
 * satelliteComs manages the communication from both the Earth to the Satellite and
 * the Satellite back to Earth. The primary communication from the Earth to the Satellite
 * is the thruster command. The primary communication from the Satellite to the Earth are the status
 * variables described above.
 *
 *
 * psuedocode:
 *
 * if first bit is a 0
 *  update thruster command to random command
 * else
 *  set thruster command to "invalid command" ~0
 *
 * send status info back to earth
 *
 *
 *
 *
 *  author: Nick Orlov
*****************************************************************************/

void satelliteComs(void* satelliteComsData) {
    // return early if less than 5 seconds have passed
    static unsigned long lastRunTime;
    if (globalTimeBase() - lastRunTime < MAJOR_CYCLE_DURATION_MS) {
        return;
    }
    lastRunTime = globalTimeBase();

    SatelliteComsData* data = (SatelliteComsData*) satelliteComsData;

    // 50/50 Chance for the command to be random or invalid
    // Last bit 0: random, Last bit 1: Invalid
    *data->thrusterCommand = rand();
    if (*data->thrusterCommand & 1) {
        *data->thrusterCommand = THRUSTER_CMD_NONE;
    }

    // send binary telemetry packets
    sendTelemetryPacket(thrusterSubsystemTCB.data,
        sizeof(ThrusterSubsystemData), TLMID_THRUSTER_DATA);

    // Transferring data back to earth
    Serial.print(F("Fuel Low status is: "));
    printBool(*data->fuelLow);
    Serial.println();
    Serial.print(F("Battery Low status is: "));
    printBool(*data->batteryLow);
    Serial.println();
    Serial.print(F("Solar Panel state is: "));
    printSolarPanelState(*data->solarPanelState);
    Serial.println();
    Serial.print(F("Battery Level is: "));
    Serial.print(data->batteryLevelPtr[0]);
    Serial.println(F("V"));
    Serial.print(F("Fuel Level is: "));
    Serial.println(*data->fuelLevel);
    Serial.print(F("Power Consumption is: "));
    Serial.println(*data->powerConsumption);
    Serial.print(F("Power Generation is: "));
    Serial.println(*data->powerGeneration);
    Serial.print(F("Vehicle Response: A "));
    Serial.println(*data->vehicleResponse);

    // process commands
    while (sync()) {
        processCommand();
    }
}

void printBool(bool input) {
    if (input) {
        Serial.print(F("true"));
    } else {
        Serial.print(F("false"));
    }
}

void printSolarPanelState(SolarPanelState state) {
    switch(state) {
        case SOLAR_PANEL_DEPLOYED:
            Serial.print(F("deployed"));
            break;
        case SOLAR_PANEL_DEPLOYING:
            Serial.print(F("deploying"));
            break;
        case SOLAR_PANEL_RETRACTING:
            Serial.print(F("retracting"));
            break;
        case SOLAR_PANEL_RETRACTED:
            Serial.print(F("retracted"));
            break;
    }
}

void sendTelemetryPacket(void *data, size_t size, uint8_t tlmId) {
    // write the header, which is really just the telemetry ID
    Serial.write(tlmId);

    // write the data
    Serial.write((uint8_t *) data, size);
}

void processCommand() {
    // read the header
    uint8_t length;
    uint8_t entityId;
    uint8_t opcode;
    Serial.readBytes(&length, 1);
    Serial.readBytes(&entityId, 1);
    Serial.readBytes(&opcode, 1);

    // read the body of the command
    uint8_t data[256];
    Serial.readBytes(data, length);

    // dispatch to different entities
    for (uint8_t i = 0; i < numCommandHandlers; i++) {
        CommandHandler *h = &commandHandlers[i];
        if (entityId == h->entityId) {
            h->handle(opcode, data);
            break;
        }
    }
}

bool sync() {
    static uint8_t i = 0;
    uint32_t pattern = COMMAND_SYNC_PATTERN;
    uint8_t *p = (uint8_t *) pattern;
    while (Serial.available()) {
        uint8_t next = Serial.read();
        if (next == p[i]) {
            // if this byte matched, move onto the next byte in the pattern
            i++;
            if (i == 4) {
                // if that was the last byte, it's synced
                i = 0;
                return true;
            }
        } else {
            // if this byte didn't match the sync pattern, fall back to start
            i = 0;
        }
    }
    return false;
}

void satelliteComsRegisterCmdHandler(uint8_t entityId,
        cmd_handler_fn handler) {
    if (numCommandHandlers >= MAX_COMMAND_HANDLERS) {
        Serial.println(F("ERROR! Too many command handlers!"));
        return;
    }
    commandHandlers[numCommandHandlers++] = {
        entityId,
        handler
    };
}
